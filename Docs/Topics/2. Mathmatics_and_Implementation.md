## 📌 1. 약수 대신 배수로 뒤집는 사고 (수학적 최적화) | O(n)

### 🔍 문제 상황

- 문제: 자연수 N이 주어졌을 때, 1부터 N까지 모든 수의 **약수의 합을 누적한 값** g(N)을 구하라.
- 전통적 접근: 각 수마다 약수를 직접 구한다 → 시간복잡도 O(n√n)

### 💡 핵심 발상

- 약수를 직접 찾는 대신, **각 수가 다른 수들의 약수로서 몇 번 등장하는지**를 계산한다.
- 어떤 수 i는 1부터 N까지 중 **자신의 배수**에 해당하는 수들의 약수로 등장한다.
- i는 1부터 N까지 총 \( \left\lfloor \frac{N}{i} \right\rfloor \)번 등장한다.

### 📘 수식 정리

$$
g(N) = \sum\_{i=1}^{N} i \cdot \left\lfloor \frac{N}{i} \right\rfloor
$$

### ✅ 예시 (N = 5)

- i = 1 → 등장 5번 (1~5 모두에 약수로 등장)
- i = 2 → 등장 2번 (2, 4)
- i = 3 → 등장 1번 (3)
- i = 4 → 등장 1번 (4)
- i = 5 → 등장 1번 (5)

총합 = 1×5 + 2×2 + 3×1 + 4×1 + 5×1 = **21**

### ⚙️ 구현

```python
def sum_of_divisors_via_multiples(n: int):
    answer = 0
    for i in range(1, n + 1):
        answer += (n // i) * i
    return answer
```

### 🧠 요약

- 약수 기준이 아니라 **배수 기준으로 역산**한다.
- 모든 수에 대해 약수를 찾는 대신, **각 수가 얼마나 자주 약수로 등장하는지**를 누적 계산한다.
- 시간복잡도 O(n)으로 대폭 최적화된다.

### ✅ 알고리즘에서 나눗셈의 진짜 쓰임

나눗셈은 생각보다 고차원적 의미를 가지는 연산이다.
생각하기에 따라서는 나눗셈의 **몫**은 **패턴의 밀도**나 **배치 가능 횟수**로 그리고 **나머지**는 **패턴의 불완전성** 또는 **정렬되지 못한 여백**으로 해석할 수 있다.

예를 들어, “10에는 3이 세 번 들어간다.” 라는 말을
“10보다 작거나 같은 3의 배수가 3개 있다.”로 이해할 수 있어야 한다

| 맥락              | 사고 방식                                               |
| ----------------- | ------------------------------------------------------- |
| 시간 복잡도 추정  | “이 연산은 n/2만큼 반복된다” → 반복의 밀도              |
| 배수/약수 문제    | “n 이하의 k의 배수 개수는?” → ⌊n / k⌋                   |
| 정렬 간 그룹 분할 | “k개씩 나누면 몇 묶음?” → 올림 ⌈n / k⌉                  |
| 그리디 문제       | “최대 몇 번까지 이 연산을 할 수 있나?” → 분할 구조 파악 |

<br />

## 📌 2. 모듈러 누적 (Modular Accumulation) | O(n)

### 🔍 문제 상황

- 문제: “각 자릿수가 1로만 이루어진 수 중에서 주어진 수 n의 배수인 가장 작은 수의 자릿수”를 구하라.

### 💡 핵심 발상

- 예: 1, 11, 111, 1111, ... 중에서 n으로 나누어 떨어지는 최소 숫자를 찾는다.
- 수 자체를 생성하지 않고, **나머지(remainder)만 추적**한다.

### 📘 점화식

$$
\text{remainder}_k = (\text{remainder}_{k-1} \cdot 10 + 1) \bmod n
$$

- 시작값: remainder = 0
- 반복하며 remainder가 0이 되는 순간 정답

### ✅ 예시 (n = 3)

- k = 1 → remainder = 1
- k = 2 → remainder = (1×10 + 1) % 3 = 2
- k = 3 → remainder = (2×10 + 1) % 3 = 0 → 정답은 3자리

### ⚙️ 구현

```python
def modular_accumulation(n: int):
    remainder = 1 % n
    length = 1

    while remainder != 0:
        remainder = (remainder * 10 + 1) % n
        length += 1

    return length
```

### 🧠 요약

- **수 전체를 만들지 않고도**, 각 자리 수를 확장하면서 나머지만 추적해도 n의 배수 여부를 판단할 수 있다.
- 핵심은 모듈러 연산의 분배법칙:
  - 덧셈: \( (a + b) \mod c = ((a \mod c) + (b \mod c)) \mod c \)
  - 곱셈: \( (a \cdot b) \mod c = ((a \mod c) \cdot (b \mod c)) \mod c \)
- 계산 효율성과 메모리 효율을 모두 잡을 수 있는 전략이다.

<br />

## 📌 3. 유클리드 호제법 (Euclidean Algorithm) | O(log n)

### 🔖 개요

유클리드 호제법은 두 자연수의 **최대공약수(GCD)**를 빠르게 구하는 고대의 알고리즘으로, **O(log n)**의 시간복잡도로 동작한다. `호제(互除)`란 "서로 나눈다"는 뜻이며, 이 알고리즘은 고대 그리스 수학자 유클리드의 『원론』에 등장한 인류 최초의 알고리즘으로 알려져 있다.

### 💡 핵심 발상

자연수 \( a, b \) (\( a > b \))에 대하여 다음과 같이 나눗셈을 수행한다고 하자:

$$
a = bq + r \quad (0 \le r < b)
$$

이때 다음이 성립한다:

$$
\gcd(a, b) = \gcd(b, r)
$$

이 과정을 \( r = 0 \)이 될 때까지 반복하면, 마지막에 남는 \( b \)가 최대공약수이다.

### 📎 수학적 원리 (증명)

공약수 \( d \)가 \( a \)와 \( b \)의 공약수라면, 다음이 성립한다:

$$
a = dk_1,\quad b = dk_2
$$

이를 \( a - bq \)에 대입하면:

$$
r = a - bq = dk_1 - q \cdot dk_2 = d(k_1 - qk_2)
$$

즉, \( r \)도 \( d \)로 나누어지므로, \( d \)는 \( b \)와 \( r \)의 공약수이기도 하다. 따라서:

$$
\gcd(a, b) = \gcd(b, a \bmod b)
$$

### ✅ 예시 (24, 15)

- 24 = 15 \* 1 + 9 → gcd(24, 15) = gcd(15, 9)
- 15 = 9 \* 1 + 6 → gcd(15, 9) = gcd(9, 6)
- 9 = 6 \* 1 + 3 → gcd(9, 6) = gcd(6, 3)
- 6 = 3 \* 2 + 0 → 종료 (gcd = 3)

### ⚙️ 알고리즘 구현

- 재귀 방식

```python
def gcd(a: int, b: int) -> int:
    if b == 0:
        return a
    return gcd(b, a % b)
```

- 반복 방식

```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

### 최소 공배수

최소 공배수는 최대 공약수를 이용해 쉽게 계산이 가능하다

`lcm(a, b) = a × b // gcd(a, b)`

<br />

## 📌 4. 에라토스테네스의 체 (Sieve of Eratosthenes) | O(n log log n)

### 🔖 개요

주어진 자연수 `N`보다 작거나 같은 모든 소수를 찾기 위한 고전적인 알고리즘.

### 💡 핵심 발상

1. 2부터 `N`까지 모든 정수를 나열
2. 2는 소수이므로 남기고, 2의 배수는 모두 제거
3. 남은 수 중 다음 수(3)는 소수 → 그 배수 제거
4. 이를 반복해서 √N 이하의 수까지만 검사하면 모든 소수를 걸러낼 수 있음

### ✍️ 예시: `N = 30`

초기 배열:  
`[2, 3, 4, 5, 6, 7, 8, 9, ..., 30]`

2 제거 → 4, 6, 8, ..., 30  
3 제거 → 6, 9, 12, ..., 30  
5 제거 → 10, 15, ..., 30  
...  
√30 ≈ 5.47 → 2, 3, 5까지만 수행하면 됨

### 🧠 수학적 이유

- 어떤 합성수는 반드시 **작은 소수의 배수**로 나타남
- 따라서 √N까지만 지워도 그 이상은 자동으로 제거됨
- 예: 29는 √30보다 크지만, 29보다 작은 수의 배수가 아니므로 남게 됨

### ⚙️ 구현

```python
def sieve(n):
    is_prime = [False, False] +  * (n - 1)

    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False

    return [i for i, val in enumerate(is_prime) if val]
```

- range(2, int(MAX ** 0.5) + 1): 소수 체크를 2부터 하므로 2부터, 합성수는 √MAX 이하에서 모두 체크 가능하므로 int(MAX ** 0.5) + 1
- range(i \* i, MAX + 1, i): 이전 단계에서 지워진 수를 제외하고 가장 먼저 확인할 대상이 i \* i(단, pow(i, 2)는 실행속도 문제로 사용하지 않음)

### ✅ N의 크기에 따라 다른 알고리즘 적용하기

| 범위                | 추천 방식           | 이유                                | 시간복잡도     |
| ------------------- | ------------------- | ----------------------------------- | -------------- |
| n ≤ 100             | √n까지 브루트포스   | 반복 적음, 구현 간단                | O(√n)          |
| 100 < n ≤ 1,000,000 | 에라토스테네스의 체 | 조회 성능이 빠름, 메모리도 괜찮음   | O(n log log n) |
| n ≥ 10^7 ~ 10^18    | 밀러-라빈 (확률적)  | 체는 메모리 부담 큼, √n은 너무 느림 | O(n log n)     |

<br />

## 📌 5. 밀러-라빈 소수 판별법 (Miller–Rabin Primality Test) | O(k log n)

### 🔖 개요

큰 정수에 대해 **소수인지 판별하는 확률적 알고리즘**. 일반적으로 `10^7` 이상 혹은 `10^18`까지의 큰 수를 다룰 때 유용하며, 빠르고 실용적인 테스트 방식으로 널리 사용된다.
어떤 수가 소수면 특이한 성질을 만족해야하고, 합성수라면 그걸 만족하지 못하는데, 수학적 분해를 통해 합성수를 찾아내는 방향으로 접근한다.

주로 다음과 같은 상황에서 활용된다.

- 암호학 (RSA 키 생성)
- 블록체인 프로토콜
- 고속 소수 판별이 필요한 알고리즘 문제

### 💡 핵심 발상

페르마의 소정리를 기본 원리로 하여 이를 더 엄격하게 검증한다.

- 🔎 Fermat's Little Theorem (페르마의 소정리)

  소수 p에 대해, 임의의 정수 a에 대해:

  a^(p-1) ≡ 1 mod p
  (단, a는 p의 배수가 아니어야 함)

즉, 어떤 수 n이 소수라면, a^(n-1) ≡ 1 (mod n) 이 성립해야 한다.
그러나 위조된 합성수(카마이클 수)가 존재해 이걸 만족한다고 해서 반드시 소수는 아니다. 그래서 밀러-라빈의 검증방식이 등장했다.

- 🧠 Miller–Rabin의 아이디어

  1. `n - 1 = 2^r * d` 형태로 분해 (d는 홀수)
  2. 임의의 밑 `a`를 선택
  3. 아래 중 하나라도 만족하면 `n`은 소수일 가능성 있음:

  - `a^d ≡ 1 mod n`
  - `a^(2^i * d) ≡ -1 mod n` for some `i` in `[0, r-1]`

  4. 위 조건을 만족하지 않으면 `n`은 확정적으로 **합성수**

  <br />

  밀러-라빈은 테스트할 밑 'a'를 랜덤으로 선택하기 때문에 확률적이다.
  **일부 밑 a는 합성수인데도 테스트를 통과하는 "거짓 양성(bad base, strong liar)"이 될 수 있기 때문**에, 모든 밑을 다 테스트하지 않는 이상, 확률적 오류 가능성이 존재하게 된다.

  <br />

  이에 대응해 확률적으로는 합성수 n에 대해 k번의 테스트를 해 오류율을 줄이거나 수학적으로 안전하다고 증명된 밑만 사용하는 결정적 방식으로 밀러-라빈을 적용할 수 있다.

  <br />

  - 확률적 밀러-라빈 → 보통 5~10회 반복. 1회 시행 시 O(log n), k회 시행 시 O(k log n)

    | 반복 횟수 k | 실패 확률 (최악의 경우) |
    | ----------- | ----------------------- |
    | 1번         | ≤ 25%                   |
    | 2번         | ≤ 6.25%                 |
    | 5번         | ≤ 0.1%                  |
    | 10번        | ≤ 0.00001%              |

  - 결정적 밀러-라빈 → 수학자들이 증명한 "어떤 범위 이하의 모든 합성수"에 대해 밀러-라빈을 실패시키는 고정된 밑 a가 존재. 이 밑을 대상으로 테스트 수행

    | 범위 (n < ...)                    | 결정적 테스트용 밑 a                         | 특징                                                                      |
    | --------------------------------- | -------------------------------------------- | ------------------------------------------------------------------------- |
    | 2^32 (약 43억)                    | [2, 3]                                       |                                                                           |
    | 3,317,444,400,000,000,000 (3.3경) | [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37] | 수학자들이 밀러-라빈의 결정적 동작을 확인한 최대 범위                     |
    | 2^64 (184경)                      | 위와 동일                                    | 컴퓨터 아키텍처에서 중요한 범위. 경험적으로 안전하다고 간주되며 널리 사용 |

### ⚙️ 구현

```python
def is_probable_prime(n: int, k: int = 5) -> bool:
    import random

    if n < 2:
        return False
    if n in (2, 3):
        return True
    if n % 2 == 0:
        return False

    # Write n-1 as 2^r * d
    d = n - 1
    r = 0
    while d % 2 == 0:
        d //= 2
        r += 1

    # Repeat k times for different random bases
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, d, n)
        if x in (1, n - 1):
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True
```

- `k`: 테스트 반복 횟수 (기저 개수), 보통 5~10이면 충분
- `pow(a, d, n)`: 빠른 제곱 (모듈로 연산 포함)
