## 📌 1. 약수 대신 배수로 뒤집는 사고 (수학적 최적화) | O(n)

### 🔍 문제 상황

- 문제: 자연수 N이 주어졌을 때, 1부터 N까지 모든 수의 **약수의 합을 누적한 값** g(N)을 구하라.
- 전통적 접근: 각 수마다 약수를 직접 구한다 → 시간복잡도 O(n√n)

### 💡 핵심 발상

- 약수를 직접 찾는 대신, **각 수가 다른 수들의 약수로서 몇 번 등장하는지**를 계산한다.
- 어떤 수 i는 1부터 N까지 중 **자신의 배수**에 해당하는 수들의 약수로 등장한다.
- i는 1부터 N까지 총 \( \left\lfloor \frac{N}{i} \right\rfloor \)번 등장한다.

### 📘 수식 정리

$$
g(N) = \sum\_{i=1}^{N} i \cdot \left\lfloor \frac{N}{i} \right\rfloor
$$

### ✅ 예시 (N = 5)

- i = 1 → 등장 5번 (1~5 모두에 약수로 등장)
- i = 2 → 등장 2번 (2, 4)
- i = 3 → 등장 1번 (3)
- i = 4 → 등장 1번 (4)
- i = 5 → 등장 1번 (5)

총합 = 1×5 + 2×2 + 3×1 + 4×1 + 5×1 = **21**

### ⚙️ 구현

```python
def sum_of_divisors_via_multiples(n: int):
    answer = 0
    for i in range(1, n + 1):
        answer += (n // i) * i
    return answer
```

### 🧠 요약

- 약수 기준이 아니라 **배수 기준으로 역산**한다.
- 모든 수에 대해 약수를 찾는 대신, **각 수가 얼마나 자주 약수로 등장하는지**를 누적 계산한다.
- 시간복잡도 O(n)으로 대폭 최적화된다.

### ✅ 알고리즘에서 나눗셈의 진짜 쓰임

나눗셈은 생각보다 고차원적 의미를 가지는 연산이다.
생각하기에 따라서는 나눗셈의 **몫**은 **패턴의 밀도**나 **배치 가능 횟수**로 그리고 **나머지**는 **패턴의 불완전성** 또는 **정렬되지 못한 여백**으로 해석할 수 있다.

예를 들어, “10에는 3이 세 번 들어간다.” 라는 말을
“10보다 작거나 같은 3의 배수가 3개 있다.”로 이해할 수 있어야 한다

| 맥락              | 사고 방식                                               |
| ----------------- | ------------------------------------------------------- |
| 시간 복잡도 추정  | “이 연산은 n/2만큼 반복된다” → 반복의 밀도              |
| 배수/약수 문제    | “n 이하의 k의 배수 개수는?” → ⌊n / k⌋                   |
| 정렬 간 그룹 분할 | “k개씩 나누면 몇 묶음?” → 올림 ⌈n / k⌉                  |
| 그리디 문제       | “최대 몇 번까지 이 연산을 할 수 있나?” → 분할 구조 파악 |

<br />

## 📌 2. 모듈러 누적 (Modular Accumulation) | O(n)

### 🔍 문제 상황

- 문제: “각 자릿수가 1로만 이루어진 수 중에서 주어진 수 n의 배수인 가장 작은 수의 자릿수”를 구하라.

### 💡 핵심 발상

- 예: 1, 11, 111, 1111, ... 중에서 n으로 나누어 떨어지는 최소 숫자를 찾는다.
- 수 자체를 생성하지 않고, **나머지(remainder)만 추적**한다.

### 📘 점화식

$$
remainder*k = (remainder*{k-1} \times 10 + 1) \mod n
$$

- 시작값: remainder = 0
- 반복하며 remainder가 0이 되는 순간 정답

### ✅ 예시 (n = 3)

- k = 1 → remainder = 1
- k = 2 → remainder = (1×10 + 1) % 3 = 2
- k = 3 → remainder = (2×10 + 1) % 3 = 0 → 정답은 3자리

### ⚙️ 구현

```python
def modular_accumulation(n: int):
    remainder = 1 % n
    length = 1

    while remainder != 0:
        remainder = (remainder * 10 + 1) % n
        length += 1

    return length
```

### 🧠 요약

- **수 전체를 만들지 않고도**, 각 자리 수를 확장하면서 나머지만 추적해도 n의 배수 여부를 판단할 수 있다.
- 핵심은 모듈러 연산의 분배법칙:
  - 덧셈: \( (a + b) \mod c = ((a \mod c) + (b \mod c)) \mod c \)
  - 곱셈: \( (a \cdot b) \mod c = ((a \mod c) \cdot (b \mod c)) \mod c \)
- 계산 효율성과 메모리 효율을 모두 잡을 수 있는 전략이다.

<br />

## 📌 3. 유클리드 호제법 (Euclidean Algorithm) | O(log n)

### 🔖 개요

유클리드 호제법은 두 자연수의 **최대공약수(GCD)**를 빠르게 구하는 고대의 알고리즘으로, **O(log n)**의 시간복잡도로 동작한다. `호제(互除)`란 "서로 나눈다"는 뜻이며, 이 알고리즘은 고대 그리스 수학자 유클리드의 『원론』에 등장한 인류 최초의 알고리즘으로 알려져 있다.

### 💡 핵심 발상

자연수 \( a, b \) (\( a > b \))에 대하여 다음과 같이 나눗셈을 수행한다고 하자:

$$
a = bq + r \quad (0 \le r < b)
$$

이때 다음이 성립한다:

$$
\gcd(a, b) = \gcd(b, r)
$$

이 과정을 \( r = 0 \)이 될 때까지 반복하면, 마지막에 남는 \( b \)가 최대공약수이다.

### 📎 수학적 원리 (증명)

공약수 \( d \)가 \( a \)와 \( b \)의 공약수라면, 다음이 성립한다:

$$
a = dk_1,\quad b = dk_2
$$

이를 \( a - bq \)에 대입하면:

$$
r = a - bq = dk_1 - q \cdot dk_2 = d(k_1 - qk_2)
$$

즉, \( r \)도 \( d \)로 나누어지므로, \( d \)는 \( b \)와 \( r \)의 공약수이기도 하다. 따라서:

$$
\gcd(a, b) = \gcd(b, a \% b)
$$

### ✅ 예시 (24, 15)

- 24 = 15 \* 1 + 9 → gcd(24, 15) = gcd(15, 9)
- 15 = 9 \* 1 + 6 → gcd(15, 9) = gcd(9, 6)
- 9 = 6 \* 1 + 3 → gcd(9, 6) = gcd(6, 3)
- 6 = 3 \* 2 + 0 → 종료 (gcd = 3)

### ⚙️ 알고리즘 구현

- 재귀 방식

```python
def gcd(a: int, b: int) -> int:
    if b == 0:
        return a
    return gcd(b, a % b)
```

- 반복 방식

```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

### 최소 공배수

최소 공배수는 최대 공약수를 이용해 쉽게 계산이 가능하다

`lcm(a, b) = a × b // gcd(a, b)`

<br />

## 📌 4. 에라토스테네스의 체 (Sieve of Eratosthenes) | O(n log log n)

### 🔖 개요

주어진 자연수 `N`보다 작거나 같은 모든 소수를 찾기 위한 고전적인 알고리즘.

### 💡 핵심 발상

1. 2부터 `N`까지 모든 정수를 나열
2. 2는 소수이므로 남기고, 2의 배수는 모두 제거
3. 남은 수 중 다음 수(3)는 소수 → 그 배수 제거
4. 이를 반복해서 √N 이하의 수까지만 검사하면 모든 소수를 걸러낼 수 있음

### ✍️ 예시: `N = 30`

초기 배열:  
`[2, 3, 4, 5, 6, 7, 8, 9, ..., 30]`

2 제거 → 4, 6, 8, ..., 30  
3 제거 → 6, 9, 12, ..., 30  
5 제거 → 10, 15, ..., 30  
...  
√30 ≈ 5.47 → 2, 3, 5까지만 수행하면 됨

### 🧠 수학적 이유

- 어떤 합성수는 반드시 **작은 소수의 배수**로 나타남
- 따라서 √N까지만 지워도 그 이상은 자동으로 제거됨
- 예: 29는 √30보다 크지만, 29보다 작은 수의 배수가 아니므로 남게 됨

### ⚙️ 구현

```python
def sieve(n):
    is_prime = [False, False] +  * (n - 1)

    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False

    return [i for i, val in enumerate(is_prime) if val]
```

- range(2, int(MAX ** 0.5) + 1): 소수 체크를 2부터 하므로 2부터, 합성수는 √MAX 이하에서 모두 체크 가능하므로 int(MAX ** 0.5) + 1
- range(i \* i, MAX + 1, i): 이전 단계에서 지워진 수를 제외하고 가장 먼저 확인할 대상이 i \* i(단, pow(i, 2)는 실행속도 문제로 사용하지 않음)
