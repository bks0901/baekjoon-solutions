## ⏱️ 시간복잡도 (Time Complexity)

### 🔸 정의

입력 크기
𝑁
N이 커질수록, 알고리즘이 몇 번 연산을 수행하는지를 표현한 것.

### 🔸 왜 중요한가?

프로그래밍 대회, 코딩 테스트, 실무 API 설계까지 실행 시간 제한이 있기 때문.

예를 들어 N = 10^6인데 알고리즘이 O(N²)이면 → 1조 번 계산 → 시간 초과(TLE)

### 🔸 대표적인 Big-O 복잡도 계층

| Big-O      | 의미          | 예시 알고리즘            |
| ---------- | ------------- | ------------------------ |
| O(1)       | 상수 시간     | 해시 접근, 인덱스 접근   |
| O(log N)   | 로그 시간     | 이진 탐색                |
| O(N)       | 선형 시간     | 선형 탐색, 배열 순회     |
| O(N log N) | 준선형 시간   | 병합 정렬, 퀵 정렬       |
| O(N²)      | 이중 반복문   | 버블 정렬, 완전 탐색     |
| O(2^N)     | 지수 시간     | 부분 집합 생성, 백트래킹 |
| O(N!)      | 팩토리얼 시간 | 순열 완전탐색 (ex. TSP)  |

### 🔸 실전 판단 기준 (입력 크기)

| N 크기    | 가능한 시간복잡도     |
| --------- | --------------------- |
| ≤ 10      | O(N!), O(2^N)도 가능  |
| ≤ 100     | O(N³) 이하            |
| ≤ 1,000   | O(N²) 이하            |
| ≤ 100,000 | O(N log N) 이하       |
| ≤ 10⁷~10⁸ | O(N), O(log N)만 가능 |

<br>

## 🧠 공간복잡도 (Space Complexity)

### 🔸 정의

알고리즘이 동작하면서 추가로 사용하는 메모리 공간량

### 🔸 계산 방식

입력 크기
𝑁
N과 관련된 변수, 배열, 함수 호출 스택 등 모두 고려

일반적으로 입력과 별도로 선언한 배열, 리스트 크기 등을 봄

### 🔸 예시

```python
arr = list(map(int, input().split())) # 입력: N개
count = [0] _ 1000 # O(1) 공간
dp = [0] _ N # O(N) 공간
```

🔸 중요한 포인트
실무에서는 **메모리 제한 (128MB, 256MB 등)**이 명시됨

int는 4바이트, float는 8바이트, bool은 1바이트

100_000개의 정수 배열은 약 400KB (= 100,000 \* 4B)

<br>

## ✍️ 예제: 배열에서 특정 값 찾기

```python
def find(x, arr):
    for i in arr:
        if i == x:
            return True
        return False
```

시간복잡도: O(N) (최악의 경우 배열 끝까지 순회)
공간복잡도: O(1) (입력 외의 추가 공간 없음)

<br>

## ⚠️ 자주 하는 실수

| 실수                                  | 더 좋은 사고 방식                                           |
| ------------------------------------- | ----------------------------------------------------------- |
| O(N log N) 정렬이 항상 빠르다         | 데이터가 거의 정렬되어 있으면 O(N) 삽입 정렬이 빠를 수 있음 |
| 공간복잡도는 신경 안 써도 된다        | 제한 메모리를 초과하면 런타임 에러 발생                     |
| 입력값 크기 보고 무작정 완전탐색 시도 | 입력 범위에 따라 적절한 전략 선택 필요                      |
