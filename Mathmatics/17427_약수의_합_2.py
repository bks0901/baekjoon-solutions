"""
## [17427] 약수의 합 2
🔗 https://www.acmicpc.net/problem/17427
"""

# 💡 Idea. 고전적 최적화 → 약수 기준이 아닌 배수 기준!

def solution(n):

    answer = 0

    for i in range(1, n + 1):
        answer += i * (n // i)

        # ❗ Note. 약수의 합 대신 배수의 합!
        # 브루트 포스 풀이처럼 각 수의 약수를 찾아서 문제 풀이를 할 수도 있겠지만
        # 반대로 각 숫자 입장에서 자신을 약수로 가지는 수의 집합을 찾을 수도 있다
        # 수학적으로 어떤 수의 약수를 i라고 할 때, g(n)에서 i는 ⌊n/i⌋번 등장한다
        # 예를 들어 g(5)를 계산한다고 하자
        # i = 1 → 1은 1, 2, 3, 4, 5의 약수 → 5번 등장
        # i = 2 → 2는 2, 4의 약수 → 2번 등장 (2의 배수 2개)
        # i = 3 → 3은 3의 약수 → 1번 등장 (3의 배수 1개)
        # i = 4 → 4는 4의 약수 → 1번 등장
        # i = 5 → 5는 5의 약수 → 1번 등장
        # 이처럼 i는 1부터 n까지 ⌊n/i⌋번 등장하므로, g(n)은 i * ⌊n/i⌋ 의 누적 합으로 계산할 수 있다
        # 이 알고리즘은 O(n) 시간복잡도로 매우 효율적이다

        # ❗ Note. 브루트포스 풀이
        # 아래 코드와 같은 브루트포스 풀이도 가능하다
        #     answer = 0
        #     for a in range(1, n+1):
        #         for b in range(1, a+1):
        #             if a % b == 0:
        #                 answer += b 

        # 그렇지만 이런 브루트포스 풀이는 O(n*n^1/2)로 n값이 클수록 시간이 매우 오래 걸린다
        # 오늘 풀이와 같은 고전적 최적화 트릭이 애용되는 이유가 여기에 있다

    return answer



if __name__ == "__main__":
    import sys
    input = sys.stdin.readline

    n = int(input())
    print(solution(n))


# 📘 Learnings.
# 나눈셈은 상상 이상으로 고차원적인 연산이다
# 예를 들어 10 / 3 = 3.333... 이라는 것은 성인에게 상식이지만
# 관점을 살짝 바꾸면 10에는 3이 세번 들어감 -> 10보다 작은 3의 배수는 3개
# 즉, 반복된 덧셈이 몇 회 가능한가? 그리고 문제 전체를 얼마나 쪼갤 수 있는가?